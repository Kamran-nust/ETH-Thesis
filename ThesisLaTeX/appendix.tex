\chapter{APIs}
\section{Google Static Maps API}\label{app:apimap}
The URL usage of Google Static Maps API is as follows.
\begin{lstlisting}[frame=single]
https://maps.googleapis.com/maps/api/staticmap?
	maptype=<MAP TYPE>&
	center=<LATITUDE>,<LONGITUDE>&
	zoom=<ZOOM LEVEL>&
	size=<IMAGE WIDTH>x<IMAGE HEIGHT>&
	scale=<SCALE>&
	key=<GOOGLE MAPS APIS KEY>
\end{lstlisting}

The corresponding possible values of parameters are illustrated in table \ref{tab:googlemapsapi}. Note that the parameters should be valid.

\begin{table}[!h]
	\centering
	\caption[Parameters of Google Static Maps API]{Parameters of Google Static Maps API.}
	\label{tab:googlemapsapi}
	\begin{tabular}{l|l}
	\hline
	\textbf{Item} & \textbf{Value} \\
	\hline
	Map Type & satellite / roadmap / hybrid \\
	Latitude & $(-90, 90]$ \\
	Longitude & $(-180, 180]$ \\
	Zoom Level & 1--21 \\
	Image Width & 1--640 \\
	Image Height & 1--640 \\
	Scale & 1 or 2 \\
	Google Maps APIs Key & Provided by Google. \\
	\hline
	\end{tabular}
\end{table}

\newpage

\section{OpenStreetMap}\label{app:apiosm}
The URL usage of OpenStreetMap is as follows.

\begin{lstlisting}[frame=single]
https://www.openstreetmap.org/api/0.6/map?bbox=
	<LOWER BOUND>%2C
	<LEFT BOUND>%2C
	<UPPER BOUND>%2C
	<RIGHT BOUND>%2C
\end{lstlisting}

The corresponding possible values of parameters are illustrated in table \ref{tab:osmapi}. Note that the parameters should be valid and the bounding box should not be too large.

\begin{table}[!h]
	\centering
	\caption[Parameters of OpenStreetMap]{Parameters of OpenStreetMap.}
	\label{tab:osmapi}
	\begin{tabular}{l|l}
	\hline
	\textbf{Item} & \textbf{Value} \\
	\hline
	Lower \& Upper Bound & $(-90, 90]$ \\
	Left \& Right Bound & $(-180, 180]$ \\
	\hline
	\end{tabular}
\end{table}

For the detailed XML structure of obtained \lstinline{.osm} file, please refer to  its official website\footnote{\lstinline{https://wiki.openstreetmap.org/wiki/OSM_XML}}.

\chapter{Algorithms}
\section{Projection}\label{app:projec}
According to the Google Maps JavaScript API \footnote{https://developers.google.com/maps/documentation/javascript/coordinates}, the process of projecting longitude and latitude coordinates $(p_{\text{lon}},p_{\text{lat}})$ in \textbf{radian} to its world pixel coordinates $(p_x, p_y)$ is described as
\begin{equation}
p_x = c\cdot2^z(\frac{1}{2}+\frac{1}{2\pi}p_{\text{lon}}),
\end{equation}
\begin{equation}
p_y = c\cdot2^z(\frac{1}{2}-\frac{1}{4\pi}\ln\frac{1+\sin{p_{\text{lat}}}}{1-\sin{p_{\text{lat}}}}),
\end{equation}
where $c$ is a constant, referring to the so-called tile size, which is 256 in Google Maps APIs.

\section{Order of Polygon Vertices}\label{app:revpoly}
The area $S$ of a polygon $P = \{(x_t, y_t)\}_{t \in \{1,2,\ldots,T\}}$ in Cartesian coordinate system can be computed as
\begin{equation}
	S = \frac{1}{2}\sum_{t=1}^{T}\begin{array}{|cc|}
		x_t & y_t \\
		x_{t+1} & y_{t+1} \\
	\end{array},
\end{equation}
where $(x_{T+1}, y_{T+1})$ refers to $(x_1, y_1)$. $S > 0$ if and only if the order of the polygon vertices is anticlockwise, and vice versa. Note that the Y axis in the pixel coordinates is contrary to the Y axis in the Cartesian coordinate system, thus $S > 0$ refers to a clockwise polygon.

\section{Shift and Resizing Adjustment}\label{app:shift}
The shift adjustment is exactly an optimization problem defined as follows. We use brute force to find out the best shift and resizing rate.
\begin{subequations}
\begin{equation}
\min_{i, j, \alpha}\ \beta_1\text{var}(I,f_{ij\alpha}) - \beta_2\text{match}(I_e, e_{ij\alpha}) - \beta_3\text{match}(I_c, c_{ij\alpha}),
\end{equation}
\begin{equation}
\text{s. t. }t_1 \leqslant \alpha \leqslant t_2, t_3 \leqslant i \leqslant t_4, t_5 \leqslant j \leqslant t_6,
\end{equation}
\begin{equation}
\text{match}(I_c, c_{ij\alpha}) \geqslant t_7,
\end{equation}
\begin{equation}
\text{diff}(I,f_{ij\alpha},f_{0,0,1}) \leqslant t_8,
\end{equation}
\begin{equation}
\text{ground}(I,f_{ij\alpha}) \leqslant t_9,
\end{equation}
\end{subequations}
where $i$ and $j$ denote the shift of polygon, $\alpha$ denotes the resizing rate of polygon, $I$, $I_e$, $I_c$ denote the original image, mask of edges, mask of corners respectively, $f_{ij\alpha}$, $e_{ij\alpha}$, $c_{ij\alpha}$ denote the set of pixels of polygon's face, edges, and corners, respectively, $\text{var}(\cdot,\cdot)$, $\text{match}(\cdot,\cdot)$, $\text{diff}(\cdot,\cdot,\cdot)$, $\text{ground}(\cdot, \cdot)$ denote the color variance of pixels, matching degrees, color difference and similarity with ground, $t_{1:9}$ and $\beta_{1:3}$ denote self-defined parameters.

\section{Anchor Assignment}\label{app:assignanchor}
\begin{equation}
\begin{aligned}
	A_{ij} = \begin{cases}
		1, & \text{if } p_i = 1 \text{ and } j = d_i, \text{ or }\\
		& j \notin \{d_i \mid i = 1,2,\ldots\} \text{ and } i = \argmax\limits_{k} \text{IoU}(a_k, g_j) \\
		0, & \text{otherwise},\\
	\end{cases}
\end{aligned}
\end{equation}
\begin{equation}
\begin{aligned}
	A_{ij} = \begin{cases}
		1, & \text{if $a_i$ is assigned to $g_j$,}\\
		0, & \text{otherwise},\\
	\end{cases}
\end{aligned}
\end{equation}
where $A$ is the assignment matrix. 

\section{Non-Maximum Suppression}\label{app:nms}
dummy text


\section{Beam Search}\label{app:bmsrch}

\begin{equation}
	p(v_0v_1 \ldots v_n) = p(v_0)p(v_1 \mid v_0)p(v_2 \mid v_0v_1) \ldots p(v_n \mid v_0v_1 \ldots v_{n-1}),
\end{equation}

$p(v_0^{(1)}),\ldots,p(v_0^{(b)})$

$p(v_1^{(1)} \mid v_0^{(i)}),\ldots,p(v_1^{(b)} \mid v_0^{(i)})$

\chapter{Prediction Results}
\section{Zurich}\label{app:predzh}
\section{Chicago}\label{app:predch}
